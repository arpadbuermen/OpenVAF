//! Generated by `gen_osdi_structs`, do not edit by hand.

use std::os::raw::{c_char, c_void};

pub const OSDI_VERSION_MAJOR_CURR: u32 = 0;
pub const OSDI_VERSION_MINOR_CURR: u32 = 4;
pub const PARA_TY_MASK: u32 = 3;
pub const PARA_TY_REAL: u32 = 0;
pub const PARA_TY_INT: u32 = 1;
pub const PARA_TY_STR: u32 = 2;
pub const PARA_KIND_MASK: u32 = (3 << 30);
pub const PARA_KIND_MODEL: u32 = (0 << 30);
pub const PARA_KIND_INST: u32 = (1 << 30);
pub const PARA_KIND_OPVAR: u32 = (2 << 30);
pub const ACCESS_FLAG_READ: u32 = 0;
pub const ACCESS_FLAG_SET: u32 = 1;
pub const ACCESS_FLAG_INSTANCE: u32 = 4;
pub const JACOBIAN_ENTRY_RESIST_CONST: u32 = 1;
pub const JACOBIAN_ENTRY_REACT_CONST: u32 = 2;
pub const JACOBIAN_ENTRY_RESIST: u32 = 4;
pub const JACOBIAN_ENTRY_REACT: u32 = 8;
pub const CALC_RESIST_RESIDUAL: u32 = 1;
pub const CALC_REACT_RESIDUAL: u32 = 2;
pub const CALC_RESIST_JACOBIAN: u32 = 4;
pub const CALC_REACT_JACOBIAN: u32 = 8;
pub const CALC_NOISE: u32 = 16;
pub const CALC_OP: u32 = 32;
pub const CALC_RESIST_LIM_RHS: u32 = 64;
pub const CALC_REACT_LIM_RHS: u32 = 128;
pub const ENABLE_LIM: u32 = 256;
pub const INIT_LIM: u32 = 512;
pub const ANALYSIS_NOISE: u32 = 1024;
pub const ANALYSIS_DC: u32 = 2048;
pub const ANALYSIS_AC: u32 = 4096;
pub const ANALYSIS_TRAN: u32 = 8192;
pub const ANALYSIS_IC: u32 = 16384;
pub const ANALYSIS_STATIC: u32 = 32768;
pub const ANALYSIS_NODESET: u32 = 65536;
pub const EVAL_RET_FLAG_LIM: u32 = 1;
pub const EVAL_RET_FLAG_FATAL: u32 = 2;
pub const EVAL_RET_FLAG_FINISH: u32 = 4;
pub const EVAL_RET_FLAG_STOP: u32 = 8;
pub const LOG_LVL_MASK: u32 = 7;
pub const LOG_LVL_DEBUG: u32 = 0;
pub const LOG_LVL_DISPLAY: u32 = 1;
pub const LOG_LVL_INFO: u32 = 2;
pub const LOG_LVL_WARN: u32 = 3;
pub const LOG_LVL_ERR: u32 = 4;
pub const LOG_LVL_FATAL: u32 = 5;
pub const LOG_FMT_ERR: u32 = 16;
pub const INIT_ERR_OUT_OF_BOUNDS: u32 = 1;

#[repr(C)]
pub struct OsdiLimFunction {
    pub name: *mut c_char,
    pub num_args: u32,
    pub func_ptr: *mut c_void,
}
#[repr(C)]
pub struct OsdiSimParas {
    pub names: *mut *mut c_char,
    pub vals: *mut f64,
    pub names_str: *mut *mut c_char,
    pub vals_str: *mut *mut c_char,
}
#[repr(C)]
pub struct OsdiSimInfo {
    pub paras: OsdiSimParas,
    pub abstime: f64,
    pub prev_solve: *mut f64,
    pub prev_state: *mut f64,
    pub next_state: *mut f64,
    pub flags: u32,
}
#[repr(C)]
pub union OsdiInitErrorPayload {
    pub parameter_id: u32,
}
#[repr(C)]
pub struct OsdiInitError {
    pub code: u32,
    pub payload: OsdiInitErrorPayload,
}
#[repr(C)]
pub struct OsdiInitInfo {
    pub flags: u32,
    pub num_errors: u32,
    pub errors: *mut OsdiInitError,
}
#[repr(C)]
pub struct OsdiNodePair {
    pub node_1: u32,
    pub node_2: u32,
}
#[repr(C)]
pub struct OsdiJacobianEntry {
    pub nodes: OsdiNodePair,
    pub react_ptr_off: u32,
    pub flags: u32,
}
#[repr(C)]
pub struct OsdiNode {
    pub name: *mut c_char,
    pub units: *mut c_char,
    pub residual_units: *mut c_char,
    pub resist_residual_off: u32,
    pub react_residual_off: u32,
    pub resist_limit_rhs_off: u32,
    pub react_limit_rhs_off: u32,
    pub is_flow: bool,
}
#[repr(C)]
pub struct OsdiParamOpvar {
    pub name: *mut *mut c_char,
    pub num_alias: u32,
    pub description: *mut c_char,
    pub units: *mut c_char,
    pub flags: u32,
    pub len: u32,
}
#[repr(C)]
pub struct OsdiNoiseSource {
    pub name: *mut c_char,
    pub nodes: OsdiNodePair,
}
#[repr(C)]
#[non_exhaustive]
pub struct OsdiDescriptor {
    pub name: *mut c_char,
    pub num_nodes: u32,
    pub num_terminals: u32,
    pub nodes: *mut OsdiNode,
    pub num_jacobian_entries: u32,
    pub jacobian_entries: *mut OsdiJacobianEntry,
    pub num_collapsible: u32,
    pub collapsible: *mut OsdiNodePair,
    pub collapsed_offset: u32,
    pub noise_sources: *mut OsdiNoiseSource,
    pub num_noise_src: u32,
    pub num_params: u32,
    pub num_instance_params: u32,
    pub num_opvars: u32,
    pub param_opvar: *mut OsdiParamOpvar,
    pub node_mapping_offset: u32,
    pub jacobian_ptr_resist_offset: u32,
    pub num_states: u32,
    pub state_idx_off: u32,
    pub bound_step_offset: u32,
    pub instance_size: u32,
    pub model_size: u32,
    pub access: fn(*mut c_void, *mut c_void, u32, u32) -> *mut c_void,
    pub setup_model: fn(*mut c_void, *mut c_void, *mut OsdiSimParas, *mut OsdiInitInfo),
    pub setup_instance:
        fn(*mut c_void, *mut c_void, *mut c_void, f64, u32, *mut OsdiSimParas, *mut OsdiInitInfo),
    pub eval: fn(*mut c_void, *mut c_void, *mut c_void, *mut OsdiSimInfo) -> u32,
    pub load_noise: fn(*mut c_void, *mut c_void, f64, *mut f64),
    pub load_residual_resist: fn(*mut c_void, *mut c_void, *mut f64),
    pub load_residual_react: fn(*mut c_void, *mut c_void, *mut f64),
    pub load_limit_rhs_resist: fn(*mut c_void, *mut c_void, *mut f64),
    pub load_limit_rhs_react: fn(*mut c_void, *mut c_void, *mut f64),
    pub load_spice_rhs_dc: fn(*mut c_void, *mut c_void, *mut f64, *mut f64),
    pub load_spice_rhs_tran: fn(*mut c_void, *mut c_void, *mut f64, *mut f64, f64),
    pub load_jacobian_resist: fn(*mut c_void, *mut c_void),
    pub load_jacobian_react: fn(*mut c_void, *mut c_void, f64),
    pub load_jacobian_tran: fn(*mut c_void, *mut c_void, f64),
    pub given_flag_model: fn(*mut c_void, u32) -> u32,
    pub given_flag_instance: fn(*mut c_void, u32) -> u32,
    pub num_resistive_jacobian_entries: u32,
    pub num_reactive_jacobian_entries: u32,
    pub write_jacobian_array_resist: fn(*mut c_void, *mut c_void, *mut f64),
    pub write_jacobian_array_react: fn(*mut c_void, *mut c_void, *mut f64),
    pub num_inputs: u32,
    pub inputs: *mut OsdiNodePair,
    pub load_jacobian_with_offset_resist: fn(*mut c_void, *mut c_void, usize),
    pub load_jacobian_with_offset_react: fn(*mut c_void, *mut c_void, usize),
}
impl OsdiDescriptor {
    pub fn access(
        &self,
        inst: *mut c_void,
        model: *mut c_void,
        id: u32,
        flags: u32,
    ) -> *mut c_void {
        (self.access)(inst, model, id, flags)
    }
    pub fn setup_model(
        &self,
        handle: *mut c_void,
        model: *mut c_void,
        sim_params: *mut OsdiSimParas,
        res: *mut OsdiInitInfo,
    ) {
        (self.setup_model)(handle, model, sim_params, res)
    }
    pub fn setup_instance(
        &self,
        handle: *mut c_void,
        inst: *mut c_void,
        model: *mut c_void,
        temperature: f64,
        num_terminals: u32,
        sim_params: *mut OsdiSimParas,
        res: *mut OsdiInitInfo,
    ) {
        (self.setup_instance)(handle, inst, model, temperature, num_terminals, sim_params, res)
    }
    pub fn eval(
        &self,
        handle: *mut c_void,
        inst: *mut c_void,
        model: *mut c_void,
        info: *mut OsdiSimInfo,
    ) -> u32 {
        (self.eval)(handle, inst, model, info)
    }
    pub fn load_noise(
        &self,
        inst: *mut c_void,
        model: *mut c_void,
        freq: f64,
        noise_dens: *mut f64,
    ) {
        (self.load_noise)(inst, model, freq, noise_dens)
    }
    pub fn load_residual_resist(&self, inst: *mut c_void, model: *mut c_void, dst: *mut f64) {
        (self.load_residual_resist)(inst, model, dst)
    }
    pub fn load_residual_react(&self, inst: *mut c_void, model: *mut c_void, dst: *mut f64) {
        (self.load_residual_react)(inst, model, dst)
    }
    pub fn load_limit_rhs_resist(&self, inst: *mut c_void, model: *mut c_void, dst: *mut f64) {
        (self.load_limit_rhs_resist)(inst, model, dst)
    }
    pub fn load_limit_rhs_react(&self, inst: *mut c_void, model: *mut c_void, dst: *mut f64) {
        (self.load_limit_rhs_react)(inst, model, dst)
    }
    pub fn load_spice_rhs_dc(
        &self,
        inst: *mut c_void,
        model: *mut c_void,
        dst: *mut f64,
        prev_solve: *mut f64,
    ) {
        (self.load_spice_rhs_dc)(inst, model, dst, prev_solve)
    }
    pub fn load_spice_rhs_tran(
        &self,
        inst: *mut c_void,
        model: *mut c_void,
        dst: *mut f64,
        prev_solve: *mut f64,
        alpha: f64,
    ) {
        (self.load_spice_rhs_tran)(inst, model, dst, prev_solve, alpha)
    }
    pub fn load_jacobian_resist(&self, inst: *mut c_void, model: *mut c_void) {
        (self.load_jacobian_resist)(inst, model)
    }
    pub fn load_jacobian_react(&self, inst: *mut c_void, model: *mut c_void, alpha: f64) {
        (self.load_jacobian_react)(inst, model, alpha)
    }
    pub fn load_jacobian_tran(&self, inst: *mut c_void, model: *mut c_void, alpha: f64) {
        (self.load_jacobian_tran)(inst, model, alpha)
    }
    pub fn given_flag_model(&self, model: *mut c_void, id: u32) -> u32 {
        (self.given_flag_model)(model, id)
    }
    pub fn given_flag_instance(&self, inst: *mut c_void, id: u32) -> u32 {
        (self.given_flag_instance)(inst, id)
    }
    pub fn write_jacobian_array_resist(
        &self,
        inst: *mut c_void,
        model: *mut c_void,
        destination: *mut f64,
    ) {
        (self.write_jacobian_array_resist)(inst, model, destination)
    }
    pub fn write_jacobian_array_react(
        &self,
        inst: *mut c_void,
        model: *mut c_void,
        destination: *mut f64,
    ) {
        (self.write_jacobian_array_react)(inst, model, destination)
    }
    pub fn load_jacobian_with_offset_resist(
        &self,
        inst: *mut c_void,
        model: *mut c_void,
        offset: usize,
    ) {
        (self.load_jacobian_with_offset_resist)(inst, model, offset)
    }
    pub fn load_jacobian_with_offset_react(
        &self,
        inst: *mut c_void,
        model: *mut c_void,
        offset: usize,
    ) {
        (self.load_jacobian_with_offset_react)(inst, model, offset)
    }
}
